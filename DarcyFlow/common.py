from mpi4py import MPI
import numpy as np
from dolfinx import fem
import dolfinx as dlf
import dolfinx.fem.petsc as dlfp
import ufl
from petsc4py import PETSc
import matplotlib.pyplot as plt
from scipy.special import logsumexp

import sys, os
sys.path.append(os.pardir)
sys.path.append(os.path.abspath(os.path.join(os.getcwd(), "../..")))
from core.model import ModelBase, EquSolverBase
from core.misc import construct_measure_matrix, Smoother, trans2scipy


class EquSolverDarcyFlow(EquSolverBase):
    '''
    Steady state Darcy flow equation:
        -\nabla\cdot(e^{u}\grad w) = f, in \Omega,
        w = wD, on \partial\Omega.
    For the above equation, we refer to the following article [1], which list the forward, adjoint,
    incremental forward, and incremental adjoint equations.
    For a general introduction about adjoint method, we refer to [2].

    Ref:
    [1] Junxiong Jia, Peijun Li, Deyu Meng,
    Stein variational gradient descent on infinite-dimensional space and applications to statistical inverse problems,
    SIAM Journal on Numerical Analysis, 60(4), 2225--2252.
    [2] O. Ghattas, K. Willcox,
    Learning physics-based models from data: perspectives from inverse problems and model reduction,
    Acta Numerica, 2021
    '''
    def __init__(self, mesh, u=None, f=None, wD=None, degree=1):
        '''
        Input:
            mesh: mesh generated by dolfinx.mesh
            u: a function that will be interpolate on Vh
            f: the external force function
            wD: the boundary function w == wD on boundary
            degree: the degree of the function space
        '''
        super().__init__()
        self.mesh = mesh
        self.degree = degree
        self.Vh = fem.FunctionSpace(mesh, ("Lagrange", degree))
        self.set_params(u, f, wD)

    def set_params(self, u=None, f=None, wD=None):
        ## u, f, wD must be defined on a same space as self.Vh
        if f is None:
            f = fem.Function(self.Vh)
            f.x.array[:] = 1.0
        if u is None:
            u = fem.Function(self.Vh)
            u.x.array[:] = 1.0
        if wD is None:
            wD = fem.Function(self.Vh)
            wD.x.array[:] = 0.0
        self.f = fem.Function(self.Vh)
        self.f.interpolate(f)
        self.u = fem.Function(self.Vh)
        self.u.interpolate(u)
        self.wD = fem.Function(self.Vh)
        self.wD.interpolate(wD)
        # self.u.name = "log-permeability"
        self._init_equation()
        self._init_solver()
        self.sol_forward = fem.Function(self.Vh)
        self.sol_adjoint = fem.Function(self.Vh)
        self.sol_inc_forward = fem.Function(self.Vh)  ## solution of the incremental forward equation
        self.sol_inc_adjoint = fem.Function(self.Vh)  ## solution of the incremental ajoint equation
        self.num_dofs = len(self.u.x.array)

    def _init_equation(self):
        tdim = self.Vh.mesh.topology.dim
        fdim = tdim - 1
        self.Vh.mesh.topology.create_connectivity(fdim, tdim)
        boundary_facets = dlf.mesh.exterior_facet_indices(self.Vh.mesh.topology)
        boundary_dofs = fem.locate_dofs_topological(self.Vh, fdim, boundary_facets)
        self.bc = fem.dirichletbc(self.wD, boundary_dofs)

        ## The following code based on the tutorial: http://jsdokken.com/FEniCS23-tutorial/src/lifting.html
        u, v = ufl.TrialFunction(self.Vh), ufl.TestFunction(self.Vh)
        self._a = fem.form(ufl.inner(ufl.exp(self.u)*ufl.grad(u), ufl.grad(v))*ufl.dx)
        self.A = dlfp.assemble_matrix(self._a, bcs=[self.bc])
        self.A.assemble()
        L = fem.form(ufl.inner(self.f, v)*ufl.dx)
        b = dlfp.assemble_vector(L)
        fem.apply_lifting(b, [self._a], bcs=[[self.bc]])
        b.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)
        dlfp.set_bc(b, [self.bc])
        b.ghostUpdate(addv=PETSc.InsertMode.INSERT_VALUES, mode=PETSc.ScatterMode.FORWARD)
        self.b = b

    def _init_solver(self, comm=None):
        if comm is None:
            comm = self.Vh.mesh.comm
        self.solver = PETSc.KSP().create(comm)
        self.solver.setOperators(self.A)
        self.solver.setType(PETSc.KSP.Type.PREONLY)
        self.solver.getPC().setType(PETSc.PC.Type.LU)

    # def _update_u(self, u):
    #     assert self.u.x.array.shape[0] == u.shape[0]
    #     self.u.x.array[:] = np.array(u)

    #     u, v = ufl.TrialFunction(self.Vh), ufl.TestFunction(self.Vh)
    #     a = fem.form(ufl.inner(ufl.exp(self.u)*ufl.grad(u), ufl.grad(v))*ufl.dx)
    #     self.A = dlfp.assemble_matrix(a, bcs=[self.bc])
    #     self.A.assemble()
    #     self.solver.setOperators(self.A)
    #     self.solver.setType(PETSc.KSP.Type.PREONLY)
    #     self.solver.getPC().setType(PETSc.PC.Type.LU)
        
    def _update_u(self, u):# this new update uses the new link fun in [1]
    #CONSISTENCY OF THE BAYES METHOD FOR THE INVERSE SCATTERING PROBLEM
        assert self.u.x.array.shape[0] == u.shape[0]
        self.u.x.array[:] = np.array(u)

        u, v = ufl.TrialFunction(self.Vh), ufl.TestFunction(self.Vh)
        M0=10000
        new_link=M0/(M0+(M0-1)*(ufl.exp(-self.u)-1))
        a = fem.form(ufl.inner(new_link*ufl.grad(u), ufl.grad(v))*ufl.dx)
        self.A = dlfp.assemble_matrix(a, bcs=[self.bc])
        self.A.assemble()
        self.solver.setOperators(self.A)
        self.solver.setType(PETSc.KSP.Type.PREONLY)
        self.solver.getPC().setType(PETSc.PC.Type.LU)

    def _init_measurement_matrix(self, coordinates):
        assert coordinates.shape[1] == 3
        self.S = construct_measure_matrix(self.Vh, coordinates)

    def get_data(self, w):
        assert w.shape[0] == self.S.shape[1], "The measure matrix not in accordance with the input function"
        return np.array(self.S@w)

    def forward_solve(self, u=None):
        if u is not None:
            self._update_u(u)
        self.solver.solve(self.b, self.sol_forward.vector)
        self.sol_forward.x.scatter_forward()
        return np.array(self.sol_forward.x.array)

    def adjoint_solve(self, vec, u=None):
        if u is not None:
            self._update_u(u)

        assert self.S.shape[0] == vec.shape[0]
        Fs = fem.Function(self.Vh)
        Fs.x.array[:] = -self.S.T@vec
        dlfp.apply_lifting(Fs.vector, [self._a], [[self.bc]])
        Fs.vector.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)
        dlfp.set_bc(Fs.vector, [self.bc])
        self.solver.solve(Fs.vector, self.sol_adjoint.vector)
        self.sol_adjoint.x.scatter_forward()
        return np.array(self.sol_adjoint.x.array)

    def inc_forward_solve(self, u_hat, sol_forward=None):
        if sol_forward is not None:
            assert sol_forward.shape[0] == self.num_dofs
            self.sol_forward.x.array[:] = np.array(sol_forward)

        u_hat_fun = fem.Function(self.Vh)
        assert u_hat_fun.x.array.shape[0] == u_hat.shape[0]
        u_hat_fun.x.array[:] = np.array(u_hat)
        v = ufl.TestFunction(self.Vh)
        fu1 = fem.Constant(self.Vh.mesh, dlf.default_scalar_type(-1))
        b_ = ufl.inner(fu1*u_hat_fun*ufl.exp(self.u)*ufl.grad(self.sol_forward), ufl.grad(v))*ufl.dx
        b_ = fem.form(b_)
        b = dlfp.assemble_vector(b_)
        dlfp.apply_lifting(b, [self._a], [[self.bc]])
        b.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)
        dlfp.set_bc(b, [self.bc])
        self.solver.solve(b, self.sol_inc_forward.vector)
        self.sol_inc_forward.x.scatter_forward()

        return np.array(self.sol_inc_forward.x.array)

    def inc_adjoint_solve(self, vec, u_hat, sol_adjoint=None, simple=False):
        if sol_adjoint is not None:
             assert sol_adjoint.shape[0] == self.num_dofs
             self.sol_adjoint.x.array[:] = np.array(sol_adjoint)

        Fs = fem.Function(self.Vh)
        Fs.x.array[:] = (-(self.S.T)@vec).squeeze()

        if simple == False:
            u_hat_fun = fem.Function(self.Vh)
            u_hat_fun.x.array[:] = np.array(u_hat)
            v = ufl.TestFunction(self.Vh)
            bl_ = ufl.inner(u_hat_fun*ufl.exp(self.u)*ufl.grad(self.sol_adjoint), ufl.grad(v))*ufl.dx
            bl_ = fem.form(bl_)
            bl = dlfp.assemble_vector(bl_)
            rhs = fem.Function(self.Vh)
            rhs.x.array[:] = -bl[:] + Fs.x.array
            dlfp.apply_lifting(rhs.vector, [self._a], [[self.bc]])
            rhs.vector.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)
            dlfp.set_bc(rhs.vector, [self.bc])
            self.solver.solve(rhs.vector, self.sol_inc_adjoint.vector)
        elif simple == True:
            dlfp.apply_lifting(Fs.vector, [self._a], [[self.bc]])
            Fs.vector.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)
            dlfp.set_bc(Fs.vector, [self.bc])
            self.solver.solve(Fs.vector, self.sol_inc_adjoint.vector)

        return np.array(self.sol_inc_adjoint.x.array)


class ModelDarcyFlow(ModelBase):
    '''
    The class ModelDarcyFlow mainly gives the programs for computing gradient and Hessian.
    '''
    def __init__(self, prior, equ_solver, noise, data, smoother=None):
        super().__init__(prior, equ_solver, noise, data)
        assert hasattr(self.noise, 'eval_CM_inner')
        assert hasattr(self.prior, 'eval_grad')
        assert hasattr(self.prior, 'eval_hessian')
        assert hasattr(prior, "precondition")
        assert hasattr(self.equ_solver, 'forward_solve')
        assert hasattr(self.equ_solver, 'adjoint_solve')
        assert hasattr(self.equ_solver, 'inc_forward_solve')
        assert hasattr(self.equ_solver, 'inc_adjoint_solve')
        assert hasattr(self.equ_solver, 'S')
        self.p = fem.Function(self.equ_solver.Vh)
        self.q = fem.Function(self.equ_solver.Vh)
        self.pp = fem.Function(self.equ_solver.Vh)
        self.qq = fem.Function(self.equ_solver.Vh)
        self.function_space = self.equ_solver.Vh
        self._init_solverM()
        ## smoother is a function that take the operation (I - degree*\Delta)^{-1}f
        if smoother is None:
            smoother = Smoother(self.equ_solver.Vh, degree=0.0)
        assert hasattr(smoother, "smoothing")
        self.smoother = smoother
        self.name = "ModelDarcyFlow"

    def _init_measurement_matrix(self, coordinates):
        assert coordinates.shape[1] == 3
        self.equ_solver._init_measurement_matrix(coordinates)
        self.S = self.equ_solver.S

    def get_data(self, w):
        assert w.shape[0] == self.S.shape[1], "The measure matrix not in accordance with the input function"
        return np.array(self.S@w)

    def update_param(self, u, update_sol=True):
        self.equ_solver._update_u(u)
        if update_sol == True:
            self.equ_solver.forward_solve()

    def _init_solverM(self):
        self.solverM = PETSc.KSP().create(self.equ_solver.Vh.mesh.comm)
        self.solverM.setOperators(self.M_)
        self.solverM.setType(PETSc.KSP.Type.PREONLY)
        self.solverM.getPC().setType(PETSc.PC.Type.LU)

    def loss_res(self, u=None):
        if u is not None:
            self.equ_solver.forward_solve(u)
        d = self.get_data(self.equ_solver.sol_forward.x.array)
        assert d.shape[0] == self.data.shape[0]
        res = d - self.data
        val = 0.5*self.noise.eval_CM_inner(res)
        return val

    def loss_prior(self, u=None):
        if u is not None:
            assert u.shape[0] == self.equ_solver.num_dofs
            val = 0.5*self.prior.eval_CM_inner(u)
        else:
            val = 0.5*self.prior.eval_CM_inner(self.equ_solver.u.x.array)
        return val

    def eval_grad_res(self, u):
        self.equ_solver.forward_solve(u)
        vec = self.get_data(self.equ_solver.sol_forward.x.array) - self.noise.mean - self.data
        vec = vec/(self.noise.std_dev**2)
        self.equ_solver.adjoint_solve(vec.squeeze())
        self.p.x.array[:] = self.equ_solver.sol_forward.x.array
        self.q.x.array[:] = self.equ_solver.sol_adjoint.x.array
        v_ = ufl.TestFunction(self.equ_solver.Vh)
        b_ = ufl.inner(ufl.grad(self.q), ufl.exp(self.equ_solver.u)*ufl.grad(self.p)*v_)*ufl.dx
        b_ = fem.form(b_)
        L = fem.petsc.assemble_vector(b_)
        val = fem.Function(self.equ_solver.Vh)
        self.solverM.solve(L, val.vector)
        val.x.scatter_forward()
        return np.array(val.x.array)

    def eval_hessian_res(self, u_hat):
        assert u_hat.shape[0] == self.num_dofs
        u_hat_fun = fem.Function(self.equ_solver.Vh)
        u_hat_fun.x.array[:] = np.array(u_hat)
        self.equ_solver.inc_forward_solve(u_hat_fun.x.array)
        vec = np.array(self.S@self.equ_solver.sol_inc_forward.x.array)
        vec = vec.squeeze()
        vec = vec/(self.noise.std_dev**2)
        self.equ_solver.inc_adjoint_solve(vec, u_hat_fun.x.array)
        self.pp.x.array[:] = self.equ_solver.sol_inc_forward.x.array
        self.qq.x.array[:] = self.equ_solver.sol_inc_adjoint.x.array
        v = ufl.TestFunction(self.equ_solver.Vh)
        A1_ = ufl.inner(u_hat_fun*ufl.exp(self.equ_solver.u)*ufl.grad(self.p)*v, \
                       ufl.grad(self.q))*ufl.dx
        A1 = dlfp.assemble_vector(fem.form(A1_))
        A2_ = ufl.inner(ufl.exp(self.equ_solver.u)*ufl.grad(self.p)*v, \
                        ufl.grad(self.qq))*ufl.dx
        A2 = dlfp.assemble_vector(fem.form(A2_))
        A3_ = ufl.inner(ufl.exp(self.equ_solver.u)*ufl.grad(self.q)*v, \
                        ufl.grad(self.pp))*ufl.dx
        A3 = dlfp.assemble_vector(fem.form(A3_))
        A = fem.Function(self.equ_solver.Vh)
        A.x.array[:] = np.array(A1[:] + A2[:] + A3[:])
        val = fem.Function(self.equ_solver.Vh)
        self.solverM.solve(A.vector, val.vector)

        return np.array(val.x.array)

    ## linearized_forward_solver is actually the incremental forward solver
    def linearized_forward_solve(self, u_hat, **kwargs):
        val = self.equ_solver.inc_forward_solve(u_hat, **kwargs)
        return np.array(val)

    ## linearized_adjoint_solver is actually the incremental adjoint solver
    def linearized_adjoint_solve(self, vec, u_hat, **kwargs):
        val = self.equ_solver.inc_adjoint_solve(vec, u_hat, **kwargs)
        return np.array(val)


class Model2peak():
    def __init__(self, prior):
        self.function_space = prior.Vh
        self.prior=prior
        self.num_dofs=self.prior.M.shape[0]
        
        
        def peak(x):
            return np.cos(np.pi*x[0])
            
        peak_fun = fem.Function(prior.Vh)
        peak_fun.interpolate(peak)
        tem=peak_fun.x.array[:]
        
        # self.peak_vec1 =  1.3*tem/np.sqrt(tem @ self.prior.M @ tem)
        # self.peak_vec2 = -1.3*tem/np.sqrt(tem @ self.prior.M @ tem)
        self.peak_vec1 =  tem
        self.peak_vec2 = -tem
        

        self.noise_std=0.01*np.max(np.abs(self.peak_vec1))
        self.peak_vec1+=np.random.normal(0,self.noise_std,self.num_dofs)
        self.peak_vec2+=np.random.normal(0,self.noise_std,self.num_dofs)

        
    def loss_res(self, u):
        coef=0.5/(self.noise_std**2)
        tem_err=u-self.peak_vec1
        loss1=coef*tem_err@ self.prior.M @tem_err
        tem_err=u-self.peak_vec2
        loss2=coef*tem_err@ self.prior.M @tem_err
        # print(loss1,loss2)
        return -np.logaddexp(-loss1,-loss2)
    
    def peak2_test(self):
        tem_loss=[]
        for i in range(30):
            i-=10
            tem_vec=(1-i*0.1)*self.peak_vec1+0.1*i*self.peak_vec2
            tem_loss.append(self.loss_res(tem_vec))
        plt.figure()
        plt.plot(tem_loss)


class Model4peak():
    def __init__(self, prior):
        self.function_space = prior.Vh
        self.prior=prior
        self.num_dofs=self.prior.M.shape[0]
        
        
        def basis1(x):
            return np.sqrt(2)*np.cos(np.pi*x[0])
            
        tem_fun = fem.Function(prior.Vh)
        tem_fun.interpolate(basis1)
        
        max_val=1.3
        
        peak_vec1 =  max_val*np.array(tem_fun.x.array[:])
        peak_vec2 = -max_val*np.array(tem_fun.x.array[:])

        def basis2(x):
            return np.sqrt(2)*np.cos(np.pi*x[1])
        def basis3(x):
            return 2*np.cos(np.pi*x[0])*np.cos(np.pi*x[1])
        
        tem_fun.interpolate(basis2)
        peak_vec3 =  0.8*max_val*np.array(tem_fun.x.array[:])
        # tem_fun.interpolate(basis3)
        # peak_vec4 =  max_val*np.array(tem_fun.x.array[:])
        

        self.noise_std=0.01*np.max(np.abs(peak_vec1))
        peak_vec1+=np.random.normal(0,self.noise_std,self.num_dofs)
        peak_vec2+=np.random.normal(0,self.noise_std,self.num_dofs)
        peak_vec3+=np.random.normal(0,self.noise_std,self.num_dofs)
        # peak_vec4+=np.random.normal(0,self.noise_std,self.num_dofs)
        
        self.peaks=[peak_vec1,peak_vec2,peak_vec3]#,peak_vec4]
        
    def loss_res(self, x):
        loss=[]
        for peak in self.peaks:
            tem_loss=0.5/(self.noise_std**2) *(x-peak) @self.prior.M @ (x-peak)
            loss.append(tem_loss)
        return -logsumexp(-np.array(loss))

    def peak2_test(self):
        tem_loss=[]
        for i in range(30):
            i-=10
            tem_vec=(1-i*0.1)*self.peak_vec1+0.1*i*self.peak_vec2
            tem_loss.append(self.loss_res(tem_vec))
        plt.figure()
        plt.plot(tem_loss)





